<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org" lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>ë¯¸ë‹ˆê²Œì„ - ì‚¬ê³¼ê²Œì„</title>

  <link rel="stylesheet" href="/communityCss/applegame.css" />
  <link href="https://fonts.googleapis.com/css2?family=Do+Hyeon&display=swap" rel="stylesheet" />
</head>

<body>
  <th:block th:include="common/header"></th:block>

  <section class="applegame" id="appleTop">
    <h1>ğŸ ì‚¬ê³¼ê²Œì„</h1>

    <div class="applegame-controls">
      <button id="startBtn" type="button">ê²Œì„ ì‹œì‘</button>
      <div id="score">Score : 0</div>
      <div id="timerContainer" aria-label="ë‚¨ì€ ì‹œê°„">
        <div id="timerBar">
          <div id="timerBarFill"></div>
        </div>
      </div>
    </div>

    <div class="applegame-board">
      <div class="applegame-board-inner">
        <div id="gameOverlay" class="applegame-overlay" aria-live="polite">
          <div class="applegame-overlay-card">
            <div class="applegame-overlay-badge">10 ë§Œë“¤ê¸° í¼ì¦</div>
            <h2 class="applegame-overlay-title">ë“œë˜ê·¸ë¡œ ì‚¬ê³¼ë¥¼ ì„ íƒí•´ì„œ í•©ì´ 10ì´ë©´ ì œê±°!</h2>
            <p class="applegame-overlay-desc">
              ìˆ«ìê°€ ì íŒ ì‚¬ê³¼ë“¤ì„ <b>ë“œë˜ê·¸</b>ë¡œ ì˜ì—­ ì„ íƒí•˜ì„¸ìš”.<br />
              ì„ íƒí•œ ì‚¬ê³¼ ìˆ«ìì˜ <b>í•©ì´ 10</b>ì´ë©´ ì‚¬ê³¼ê°€ ì‚¬ë¼ì§€ê³  ì ìˆ˜ë¥¼ ì–»ìŠµë‹ˆë‹¤.
            </p>

            <div class="applegame-rulegrid">
              <div class="applegame-rule">
                <div class="applegame-rule-k">ì¡°ì‘</div>
                <div class="applegame-rule-v">ë§ˆìš°ìŠ¤ ë“œë˜ê·¸(ì¢Œí´ë¦­)ë¡œ ì˜ì—­ ì„ íƒ</div>
              </div>
              <div class="applegame-rule">
                <div class="applegame-rule-k">ì ìˆ˜</div>
                <div class="applegame-rule-v">ì œê±°í•œ ê°œìˆ˜ì˜ <b>ì œê³±</b> (ì˜ˆ: 3ê°œ â†’ 9ì )</div>
              </div>
              <div class="applegame-rule">
                <div class="applegame-rule-k">ì‹œê°„</div>
                <div class="applegame-rule-v"><b>120ì´ˆ</b> ì œí•œ</div>
              </div>
              <div class="applegame-rule">
                <div class="applegame-rule-k">ë³´ë„ˆìŠ¤</div>
                <div class="applegame-rule-v">ğŸ+3 ì‚¬ê³¼ í´ë¦­ ì‹œ <b>3ì </b> íšë“</div>
              </div>
            </div>

            <div class="applegame-overlay-actions">
              <button id="overlayStartBtn" type="button" class="applegame-overlay-primary">ê²Œì„ ì‹œì‘</button>
            </div>

            <div class="applegame-overlay-foot">
              íŒ: ë§ì€ ê°œìˆ˜ë¥¼ í•œ ë²ˆì— ë§ì¶”ë©´ ì ìˆ˜ê°€ í¬ê²Œ ì˜¬ë¼ê°€ìš”.
            </div>
          </div>
        </div>

        <div id="game" aria-label="ê²Œì„ ë³´ë“œ">
          <div id="scoreLogs"></div>
        </div>

        <!-- âœ… selectionBoxëŠ” ì—¬ê¸°ì„œ ì œê±° (body ëìœ¼ë¡œ ì´ë™) -->
      </div>
    </div>
  </section>

  <th:block th:include="common/footer"></th:block>

  <!-- âœ… ë“œë˜ê·¸ ë°•ìŠ¤ëŠ” body ì§ì†ìœ¼ë¡œ (fixed ê¸°ì¤€ ê¼¬ì„ ë°©ì§€) -->
  <div id="selectionBox" aria-hidden="true"></div>

  <script>
    (function () {
      const game = document.getElementById("game");
      const scoreDisplay = document.getElementById("score");
      const timerBarFill = document.getElementById("timerBarFill");
      const startBtn = document.getElementById("startBtn");

      const overlay = document.getElementById("gameOverlay");
      const overlayStartBtn = document.getElementById("overlayStartBtn");

      const selectionBox = document.getElementById("selectionBox");
      // âœ… ì•ˆì „ì¥ì¹˜: ë¬´ì¡°ê±´ bodyì— ë¶™ì—¬ fixed ê¸°ì¤€ì„ ë·°í¬íŠ¸ë¡œ ê³ ì •
      document.body.appendChild(selectionBox);

      const scoreLogs = document.getElementById("scoreLogs");

      const COLS = 17;
      const ROWS = 10;

      let score = 0;
      let timeLeft = 120;
      let timer;

      let startX = 0, startY = 0;
      let isDragging = false;

      let applesGrid = [];
      let currentSelected = [];
      let isGameRunning = false;

      const boardInner = document.querySelector(".applegame-board-inner");

      /* âœ… ë³´ë„ˆìŠ¤ ì‚¬ê³¼ê°€ ì›€ì§ì¼ "ì „ìš© ë ˆì´ì–´" */
      const timeAppleContainer = document.createElement("div");
      timeAppleContainer.className = "timeAppleLayer";
      boardInner.appendChild(timeAppleContainer);

      function showOverlay(mode, finalScore) {
        overlay.style.display = "grid";

        const title = overlay.querySelector(".applegame-overlay-title");
        const desc = overlay.querySelector(".applegame-overlay-desc");
        const badge = overlay.querySelector(".applegame-overlay-badge");
        const foot = overlay.querySelector(".applegame-overlay-foot");

        if (mode === "end") {
          badge.textContent = "ê²Œì„ ì¢…ë£Œ";
          title.textContent = `ìµœì¢… ì ìˆ˜: ${finalScore}ì `;
          desc.innerHTML = `ë‹¤ì‹œ í•œ ë²ˆ ë„ì „í•´ë³¼ê¹Œìš”?<br/>ë” í¬ê²Œ ë¬¶ì„ìˆ˜ë¡ ì ìˆ˜ê°€ ì œê³±ìœ¼ë¡œ ì˜¬ë¼ê°€ìš”!`;
          foot.textContent = "íŒ: 4ê°œ(16ì ), 5ê°œ(25ì )ì²˜ëŸ¼ í¬ê²Œ ë§ì¶”ë©´ ì ìˆ˜ í­ë°œ";
          overlayStartBtn.textContent = "ë‹¤ì‹œ í•˜ê¸°";
        } else {
          badge.textContent = "10 ë§Œë“¤ê¸° í¼ì¦";
          title.textContent = "ë“œë˜ê·¸ë¡œ ì‚¬ê³¼ë¥¼ ì„ íƒí•´ì„œ í•©ì´ 10ì´ë©´ ì œê±°!";
          desc.innerHTML =
            `ìˆ«ìê°€ ì íŒ ì‚¬ê³¼ë“¤ì„ <b>ë“œë˜ê·¸</b>ë¡œ ì˜ì—­ ì„ íƒí•˜ì„¸ìš”.<br/>` +
            `ì„ íƒí•œ ì‚¬ê³¼ ìˆ«ìì˜ <b>í•©ì´ 10</b>ì´ë©´ ì‚¬ê³¼ê°€ ì‚¬ë¼ì§€ê³  ì ìˆ˜ë¥¼ ì–»ìŠµë‹ˆë‹¤.`;
          foot.textContent = "íŒ: ë§ì€ ê°œìˆ˜ë¥¼ í•œ ë²ˆì— ë§ì¶”ë©´ ì ìˆ˜ê°€ í¬ê²Œ ì˜¬ë¼ê°€ìš”.";
          overlayStartBtn.textContent = "ê²Œì„ ì‹œì‘";
        }
      }

      function hideOverlay() {
        overlay.style.display = "none";
      }

      function generateApple(value) {
        const apple = document.createElement("div");
        apple.className = "apple";
        apple.dataset.value = value;

        const span = document.createElement("span");
        span.textContent = value;
        apple.appendChild(span);

        return apple;
      }

      function renderGrid() {
        const keepLogs = scoreLogs;
        game.innerHTML = "";

        for (let r = 0; r < ROWS; r++) {
          for (let c = 0; c < COLS; c++) {
            const apple = applesGrid[r][c];
            if (apple) {
              game.appendChild(apple);
            } else {
              const empty = document.createElement("div");
              empty.className = "apple-empty";
              game.appendChild(empty);
            }
          }
        }

        if (!game.contains(keepLogs)) game.appendChild(keepLogs);
      }

      function addScoreLog(points) {
        if (points <= 0) return;

        scoreLogs.innerHTML = "";

        const logItem = document.createElement("div");
        logItem.className = "scoreLogItem";
        if (points >= 6) logItem.classList.add("blue");

        logItem.innerHTML =
          `<span class="scoreLogPoints">+${points}</span>` +
          `<span class="scoreLogApple">ğŸ</span>`;

        scoreLogs.appendChild(logItem);
      }

      function updateScore() {
        scoreDisplay.textContent = "Score : " + score;
      }

      function updateTimerBar() {
        const percent = Math.max(0, (timeLeft / 120) * 100);
        timerBarFill.style.width = percent + "%";
      }

      function clearSelectedBorders() {
        currentSelected.forEach(({ apple }) => apple.classList.remove("selected"));
        currentSelected = [];
      }

      function updateSelectedApples(boxLeft, boxTop, boxRight, boxBottom) {
        clearSelectedBorders();
        let newlySelected = [];

        for (let r = 0; r < ROWS; r++) {
          for (let c = 0; c < COLS; c++) {
            const apple = applesGrid[r][c];
            if (!apple) continue;

            const rect = apple.getBoundingClientRect();
            const isOverlap = !(
              rect.right < boxLeft ||
              rect.left > boxRight ||
              rect.bottom < boxTop ||
              rect.top > boxBottom
            );

            if (isOverlap) {
              apple.classList.add("selected");
              newlySelected.push({ r, c, apple });
            }
          }
        }

        currentSelected = newlySelected;
      }

      function startGame() {
        hideOverlay();

        timeAppleContainer.innerHTML = "";

        applesGrid = [];
        score = 0;
        timeLeft = 120;
        updateScore();
        updateTimerBar();
        scoreLogs.innerHTML = "";
        currentSelected = [];
        isGameRunning = true;

        for (let r = 0; r < ROWS; r++) {
          applesGrid[r] = [];
          for (let c = 0; c < COLS; c++) {
            const rand = Math.floor(Math.random() * 9) + 1;
            applesGrid[r][c] = generateApple(rand);
          }
        }

        renderGrid();

        clearInterval(timer);
        timer = setInterval(() => {
          timeLeft--;
          updateTimerBar();
          if (timeLeft <= 0) {
            clearInterval(timer);
            isGameRunning = false;
            showOverlay("end", score);
          }
        }, 1000);
      }

      /* âœ… ë³´ë„ˆìŠ¤ ì‚¬ê³¼ (ì›€ì§ì´ë„ë¡ class/animation ì‚¬ìš©) */
      function createTimeApple() {
        if (!isGameRunning) return;
        if (timeAppleContainer.childElementCount >= 3) return;

        const apple = document.createElement("div");
        apple.className = "timeApple";
        apple.textContent = "ğŸ +3";

        const side = Math.random() < 0.5 ? "left" : "right";
        const fromTop = Math.random() < 0.5;

        apple.classList.add(side);
        apple.classList.add(fromTop ? "down" : "up");

        apple.addEventListener("animationend", () => {
          if (apple.parentNode) timeAppleContainer.removeChild(apple);
        });

        apple.addEventListener("click", (e) => {
          if (!isGameRunning) return;
          if (apple.dataset.clicked) return;

          e.stopPropagation();
          apple.dataset.clicked = "true";

          score += 3;
          updateScore();
          addScoreLog(3);

          apple.classList.remove("up", "down");
          apple.classList.add("growFade");
          apple.style.pointerEvents = "none";

          setTimeout(() => {
            if (apple.parentNode) timeAppleContainer.removeChild(apple);
          }, 700);
        });

        timeAppleContainer.appendChild(apple);
      }

      game.addEventListener("mousedown", (e) => {
        if (!isGameRunning) return;
        if (e.button !== 0) return;

        isDragging = true;
        startX = e.clientX;
        startY = e.clientY;

        selectionBox.style.left = startX + "px";
        selectionBox.style.top = startY + "px";
        selectionBox.style.width = "0px";
        selectionBox.style.height = "0px";
        selectionBox.style.display = "block";
      });

      window.addEventListener("mousemove", (e) => {
        if (!isDragging) return;

        const currentX = e.clientX;
        const currentY = e.clientY;

        const x = Math.min(startX, currentX);
        const y = Math.min(startY, currentY);
        const width = Math.abs(startX - currentX);
        const height = Math.abs(startY - currentY);

        selectionBox.style.left = x + "px";
        selectionBox.style.top = y + "px";
        selectionBox.style.width = width + "px";
        selectionBox.style.height = height + "px";

        updateSelectedApples(x, y, x + width, y + height);
      });

      window.addEventListener("mouseup", () => {
        if (!isGameRunning) return;
        if (!isDragging) return;

        isDragging = false;
        selectionBox.style.display = "none";

        const selected = currentSelected;
        const sum = selected.reduce((acc, obj) => acc + parseInt(obj.apple.dataset.value), 0);

        if (sum === 10 && selected.length > 0) {
          const points = selected.length ** 2;
          score += points;
          updateScore();
          addScoreLog(points);

          timeLeft += 5;
          updateTimerBar();

          createTimeApple();

          selected.forEach(({ r, c, apple }) => {
            apple.classList.add("vanish");
            apple.addEventListener(
              "animationend",
              () => {
                applesGrid[r][c] = null;
                renderGrid();
              },
              { once: true }
            );
          });
        }

        clearSelectedBorders();
      });

      startBtn.addEventListener("click", () => startGame());
      overlayStartBtn.addEventListener("click", () => startGame());

      showOverlay("intro", 0);
      updateTimerBar();
      updateScore();
    })();
  </script>
</body>
</html>
